# The Apriori algorithm

## 算法描述

数据挖掘方法中最流行的方法之一就是从事务数据集中找到经常出现的项目集合并且导出关联规则。由于组合的复杂性，找到一个频繁的项集（拥有高于或者等于一个用户的特定最低需求的项目集合）并不是一件容易的事情。一旦获取了项目集，要产生置信度大于或者等于用户特定的最小置信度的关联规则也很容易。

Apriori 是一个使用候选集来找到频繁项集的开创性算法。层次完备的搜索算法的特点在于项集的非单调性，即“如果一个项集不是频繁的，那么它的任何父集也不是频繁的”。按照惯例，Apriori假设在一个事务或项目集里的项目都是按照字典顺序存储的。设大小为k的频繁项目集的集合为F_k,并且他们的候选为C_k. Apriori首先扫描数据库，并通过为每个项目进行累加计数的方式寻找大小为1的频繁项集，然后收集其中那些满足最小支持需求的项集。最后以下面的三个步骤进行迭代，并且提取出所有的项集。

1． 从大小为k的频繁项集中生成大小为k+1的频繁项集的候选C_k+1。
2． 扫描数据库并且计算频繁项集的每个候选的支持。
3． 将满足最低支持要求的项目集添加到F_k+1。

Apriori算法展示在表格3中，第三行的aprori-gen函数从F_k中得到C_k+1,具体步骤如下：

1. 组合：通过将两个大小为k的频繁项集P_k和Q_k相合生成最初的大小为k+1的候选频繁项集R_k+1，P_k和Q_k的前k-1个元素是相同的。 

![](https://github.com/ankang1993/data-mining-algorithms/blob/master/figure/4.1.png)

2. 修剪：检查是否所有在R_k+1 中的大小为k的项集都是频繁的，并且通过移除R_k+1中的不满足此要求的项集来生成C_k+1。因为任何C_k+1的大小为k的不频繁的子集不可能成为大小为K+1的频繁项集的子集。

第五行的函数子集找到了所有包括事务t的频繁项集。然后Apriori可以通过扫描数据库只对用这种方式生成的候选项集计算频率。

很明显当最大的频繁项集的大小是k_max的时候，Apriori算法最多扫描K_max+1次数据库。

通过减少候选集的数目Apriori可以实现较好的性能（图3）。然而，在有很多频繁项集、大项集或者很低的最小支持的情况下，它仍然会由于要生成大量的候选集和为了检查大量的候选项集而反复扫描数据库，从而产生巨大的损耗。事实上，为了得到大小为100的频繁项集需要生成2的100次方个候选项集。

![](https://github.com/ankang1993/data-mining-algorithms/blob/master/figure/4.2.png)

## 算法的影响

大多数在数据挖掘中被频繁应用的模式查找算法诸如决策树、分类规则集和聚类技术已经在机器学习研究团体中有了很大的发展。对于这个传统而言频率模型和关联规则挖掘是少数的几个例外。这种技术的引入加快了数据挖掘的研究，它的影响也是巨大的。算法简单易于实现。数据挖掘工作者首先就会尝试使用类似Apriori的算法。

## 目前和未来的研究

自从第一次引入Apriori算法开始，随着经验的累积，对设计更高效的频繁项集的挖掘算法进行了许多的尝试。他们中的很多都使用Apriori一样的生成候选的思想。它们包括了基于哈希的技术，分割，抽样和使用垂直数据格式。基于哈希的技术能够减少候选项集的大小。通过使用合适的哈希函数，每个项集可以被哈希到一个相应的桶（bucket）中。由于一个桶可以容纳不同的项集，如果项集数量小于最小支持，就可以从候选集中移除这些桶中的项集。分隔可以用来将一整个挖掘问题分割为n个更小的问题。数据集被分割为n个互不重叠的分块，这样每个分块都能够装进主内存并且能够进行独立的挖掘。由于任何关于完整数据集可能频繁的项集必须至少需要在一个分块中成为频繁项集，这样找到的所有频繁项集都作为候选，最后通过访问一次所有数据集就能完成检查。抽样可以简单的挖掘一个从完整数据中随机抽样的小子集。由于我们无法保证能找到所有的频繁项集，常用的方法是使用一个更低的支持阈值。在准确性和效率之间必须进行权衡。Apriori使用水平数据格式，例如频繁项集与每个事务有关。使用垂直数据格式是使用一个不同的格式，在这种格式中事务ID（TIDs）与每个项集有关。使用这种格式，就可以通过使用TIDs的交集来进行挖掘。支持数量就是该项集的TID集合的长度。这样就不用再去扫描数据库了，因为TID集携带了计算支持所需要的完整信息。

对于Apriori算法最杰出的提升就是被叫做FP-growth（频率模式增长）的方法，这个方法成功的消除了候选的生成。它采用了分而治之的策略：（1）将代表频繁项集的数据库压缩进一个称为FP-tree（频繁模式树）的结构中，这个树保留了所有必要的信息（2）将压缩的数据库分割为条件数据库的集合，其中每个数据库与一个频繁项集有关并且单独对每一个进行挖掘。这个方法只扫描数据库两次。在第一次扫描中，求出所有频繁项集和他们的支持数量（频率），并且将他们按照每个事务的支持数量进行降序排列。在第二次扫描中，每个事务中的项目被合并到一个前缀树中并且计数在不同事务中一起出现的项目（节点）。每个节点都和一个项目及它的数量有关。有相同标签的节点通过一个叫做节点链的指针相互连接。由于项目按照频率的降序排列，靠近前缀树根部的节点被更多的事务所共享，这样就得到了保存有所有必要信息的紧凑的表示。通过按照频率增序选择一个项目，并在条件FP树上递归调用自身来提取包含所选项目的频繁项集，模式增长算法也适用于FP-tree。FP-growth相比较于原来的Apriori有一个量级的性能的提升。 

关于频率模式挖掘的扩展还有其他几个。最主要的包括了下列几个：（1）将分类法应用到项目中：分类法的应用使得即使在只有基本层次概念产生的不频率项集时，也可能提取到通过高层次概念表达的频繁项集。（2）增量挖掘：在这个环境中，假设数据库不是静态的，并且持续增加新的事务实例。新的算法在更新频繁项集时不需要从头重新开始。（3）对项目使用数字值：当项目与一个连续的数值相关的时候，除非让这些数字离散化，否则当前的频繁项目挖掘算法是不适用的。可以使用子空间聚类的方法来获得每个项目集中的每个项目之间的最优数值间隔。（4）使用其他非频率的测度，例如信息增益或x^2值：对于寻找判别模式这些测度是很有用的，但是不幸的是它们不满足非单调的性质。然而这些测度有一个好的性质：它们的参数是凸的，并且可以估计模式的父集的下界，这样就可以高效的修剪没有希望的模式。AprioriSMP就使用了这样的原则。（5）使用更丰富的表达而不是项集：很多算法已经适用于序列、树和图，这使得可以从一个更复杂的数据结构进行挖掘。（6）封闭的项集：如果一个项集不包含在任何其他的频繁项集中，那么这个频繁项集是封闭的。这样，一旦找到封闭项集，所有的频繁项集就能从他们中派生出来。LCM是能够最有效找到封闭项集的算法。
